#!/bin/bash
#
# docs-watcher - Documentation Steward agent watcher
#
# Uses Claude Haiku for documentation tasks:
# - Maintaining CURRENT-STATE.md
# - Generating handoff notes
# - Syncing to Notion
# - Flagging stale docs
#
# Usage:
#   docs-watcher <channel>
#
# Run in tmux:
#   tmux new-session -d -s docs-watcher '/mnt/shared/collab/scripts/docs-watcher agent-os-paper'
#

set -e

CHANNEL="${1:-agent-os-paper}"
CHANNEL_DIR="/mnt/shared/collab/channels/${CHANNEL}"
PRESENCE_DIR="/mnt/shared/collab/presence"
SCRIPTS_DIR="/mnt/shared/collab/scripts"
AGENT="docs-1"
LOG_FILE="/mnt/shared/collab/logs/docs-watcher.log"

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo -e "${msg}" >&2
    echo "${msg}" >> "${LOG_FILE}" 2>/dev/null || true
}

log_info() { log "${BLUE}INFO${NC}: $1"; }
log_ok() { log "${GREEN}OK${NC}: $1"; }
log_warn() { log "${YELLOW}WARN${NC}: $1"; }
log_err() { log "${RED}ERROR${NC}: $1"; }

# Ensure directories exist
mkdir -p "${PRESENCE_DIR}" "$(dirname "${LOG_FILE}")" 2>/dev/null || true

# Update presence file
update_presence() {
    local state="${1:-IDLE}"
    cat > "${PRESENCE_DIR}/${AGENT}.json" << EOF
{
  "agent_id": "${AGENT}",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
  "state": "AWAKE",
  "substate": "${state}",
  "watcher_pid": $$,
  "channel": "${CHANNEL}"
}
EOF
}

# Check if message is addressed to us
is_for_us() {
    local file="$1"
    local to=$(jq -r '.to // "all"' "$file" 2>/dev/null)
    local mentions=$(jq -r '.content.text // ""' "$file" 2>/dev/null | grep -o "@${AGENT}" || true)

    [[ "$to" == "$AGENT" ]] || [[ "$to" == "docs-1" ]] || [[ -n "$mentions" ]]
}

# Check if message is from us
is_from_us() {
    local file="$1"
    local from=$(jq -r '.from // ""' "$file" 2>/dev/null)
    [[ "$from" == "$AGENT" ]] || [[ "$from" == "docs-1" ]]
}

# Get recent context
get_context() {
    local n="${1:-5}"
    local context=""

    for f in $(ls -t "${CHANNEL_DIR}"/msg-*.json 2>/dev/null | head -n "$n" | tac); do
        local from=$(jq -r '.from' "$f" 2>/dev/null)
        local text=$(jq -r '.content.text // ""' "$f" 2>/dev/null)
        context="${context}[${from}]: ${text}\n\n"
    done

    echo -e "$context"
}

# Get current state summary
get_current_state() {
    if [[ -f "/mnt/shared/collab/CURRENT-STATE.md" ]]; then
        head -50 /mnt/shared/collab/CURRENT-STATE.md
    else
        echo "(CURRENT-STATE.md not found)"
    fi
}

# Invoke Haiku with docs-specific prompt
invoke_docs() {
    local message_file="$1"
    local from=$(jq -r '.from' "$message_file")
    local text=$(jq -r '.content.text // ""' "$message_file")
    local context=$(get_context 10)
    local current_state=$(get_current_state)

    # Docs-specific system prompt
    local prompt="You are docs-1, the Documentation Steward agent in a multi-agent collaboration system.

YOUR ROLE:
- Maintain CURRENT-STATE.md accuracy
- Generate handoff notes and summaries
- Sync documentation to Notion
- Flag stale or outdated documentation
- Keep session history updated

YOUR CAPABILITIES:
- Read and summarize documentation
- Propose updates to markdown files
- Generate structured handoffs
- Identify documentation gaps

YOUR GUARDRAILS:
- You can only modify documentation files (not code)
- Notion sync requires verification before proceeding
- Cannot delete files without confirmation
- Cannot overwrite CLAUDE.md without backup

WATCHED FILES:
- /mnt/shared/collab/CURRENT-STATE.md
- /mnt/shared/collab/docs/*.md
- ~/agent-collab/docs/*.md
- ~/claude-docs/**/*.md

=== CURRENT-STATE.md (first 50 lines) ===
${current_state}

=== RECENT CHANNEL MESSAGES ===
${context}

=== REQUEST FROM ${from} ===
${text}

Respond with your documentation assessment or proposed updates. Be concise.
If proposing file changes, show the diff or new content clearly.
If asked to sync to Notion, confirm the files and await verification."

    log_info "Invoking docs agent for message from ${from}..."

    local response
    response=$("${SCRIPTS_DIR}/haiku-exec" "$prompt" 2>&1) || {
        log_err "Docs invocation failed: $response"
        return 1
    }

    echo "$response"
}

# Post response to channel
post_response() {
    local response_text="$1"
    local in_reply_to="$2"

    python3 << EOF
import json
from datetime import datetime, timezone
from pathlib import Path
import secrets

now = datetime.now(timezone.utc)
msg_id = f"msg-{now.strftime('%Y%m%d-%H%M%S')}-docs-{secrets.token_hex(2)}"

msg = {
    "id": msg_id,
    "timestamp": now.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
    "session_id": "${CHANNEL}",
    "from": "docs-1",
    "to": "all",
    "type": "docs",
    "content": {
        "text": """${response_text}""",
        "code": None,
        "artifacts": []
    },
    "metadata": {
        "mode": "watcher",
        "model": "claude-3-5-haiku-20241022",
        "role": "documentation_steward",
        "in_reply_to": "${in_reply_to}"
    }
}

path = Path("${CHANNEL_DIR}") / f"{msg_id}.json"
path.write_text(json.dumps(msg, indent=2) + "\n")
print(f"Posted: {msg_id}")
EOF
}

# Main watch loop
main() {
    log_info "Starting Docs watcher for channel: ${CHANNEL}"
    log_info "Agent: ${AGENT} (Documentation Steward)"
    log_info "Watching: ${CHANNEL_DIR}"

    # Check dependencies
    if ! command -v inotifywait &> /dev/null; then
        log_err "inotifywait not found. Install with: apt install inotify-tools"
        exit 1
    fi

    if [[ ! -x "${SCRIPTS_DIR}/haiku-exec" ]]; then
        log_err "haiku-exec not found or not executable"
        exit 1
    fi

    # Initial presence
    update_presence "IDLE"
    log_ok "Presence updated: AWAKE/IDLE"

    # Track processed files
    declare -A processed

    # Mark existing files as processed
    for f in "${CHANNEL_DIR}"/msg-*.json; do
        [[ -f "$f" ]] && processed["$(basename "$f")"]=1
    done
    log_info "Marked ${#processed[@]} existing messages as read"

    # Watch for new files
    inotifywait -m -e create -e moved_to "${CHANNEL_DIR}" --format '%f' 2>/dev/null | while read -r filename; do
        [[ "$filename" != msg-*.json ]] && continue
        [[ -n "${processed[$filename]}" ]] && continue
        processed["$filename"]=1

        local filepath="${CHANNEL_DIR}/${filename}"
        sleep 0.5

        if is_from_us "$filepath"; then
            log_info "Skipping own message: ${filename}"
            continue
        fi

        if ! is_for_us "$filepath"; then
            log_info "Message not for us: ${filename}"
            continue
        fi

        log_info "New docs request: ${filename}"
        update_presence "DOCUMENTING"

        local msg_id=$(jq -r '.id' "$filepath" 2>/dev/null)

        local response
        if response=$(invoke_docs "$filepath"); then
            if [[ -n "$response" ]]; then
                log_ok "Docs response complete"
                post_response "$response" "$msg_id"
            else
                log_warn "Empty response from docs agent"
            fi
        else
            log_err "Docs request failed"
        fi

        update_presence "IDLE"
    done
}

cleanup() {
    log_info "Shutting down Docs watcher..."
    update_presence "OFFLINE"
    exit 0
}

trap cleanup SIGINT SIGTERM

main "$@"
