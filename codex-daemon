#!/usr/bin/env bash
# codex-daemon - Persistent Codex agent with session continuity
# Uses polling instead of inotifywait for NFS compatibility

set -euo pipefail

AGENT_ID="codex"
CHANNEL="${1:-agent-os-paper}"
CHANNEL_DIR="/mnt/shared/collab/channels/${CHANNEL}"
PRESENCE_DIR="/mnt/shared/collab/signals/presence"
SESSION_FILE="/mnt/shared/collab/sessions/${AGENT_ID}.session"
LOG_FILE="/mnt/shared/collab/logs/${AGENT_ID}-daemon.log"
HEARTBEAT_FILE="/mnt/shared/collab/logs/${AGENT_ID}-heartbeat.json"
CODEX_VM="100.88.166.68"
POLL_INTERVAL=2  # Seconds between polling for new messages (NFS-compatible)
MESSAGE_COUNT=0  # Track messages processed this session

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] ${BLUE}INFO${NC}: $*" | tee -a "$LOG_FILE" >&2; }
log_ok() { echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] ${GREEN}OK${NC}: $*" | tee -a "$LOG_FILE" >&2; }
log_warn() { echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] ${YELLOW}WARN${NC}: $*" | tee -a "$LOG_FILE" >&2; }
log_err() { echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] ${RED}ERROR${NC}: $*" | tee -a "$LOG_FILE" >&2; }

# Heartbeat for supervisor monitoring
write_heartbeat() {
    local status="${1:-idle}"
    local last_msg_id="${2:-}"
    python3 << EOF
import json
from datetime import datetime, timezone
from pathlib import Path

heartbeat = {
    "timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
    "session_id": "$(cat "$SESSION_FILE" 2>/dev/null | jq -r '.session_id // "none"')",
    "message_count": ${MESSAGE_COUNT},
    "last_message_id": "${last_msg_id}",
    "status": "${status}"
}

Path("${HEARTBEAT_FILE}").write_text(json.dumps(heartbeat, indent=2))
EOF
}

get_session_id() {
    if [[ -f "$SESSION_FILE" ]]; then
        local session_data session_id last_used
        session_data=$(cat "$SESSION_FILE")
        session_id=$(echo "$session_data" | jq -r '.session_id // empty')
        last_used=$(echo "$session_data" | jq -r '.last_used // empty')

        if [[ -n "$session_id" ]]; then
            local now last_ts age
            now=$(date +%s)
            last_ts=$(date -d "$last_used" +%s 2>/dev/null || echo 0)
            age=$((now - last_ts))

            if [[ $age -lt 28800 ]]; then
                echo "$session_id"
                return 0
            else
                log_warn "Session expired (age: ${age}s), will start new session"
            fi
        fi
    fi
    return 1
}

save_session_id() {
    local session_id="$1"
    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    cat > "$SESSION_FILE" << EOF
{
  "agent_id": "${AGENT_ID}",
  "session_id": "${session_id}",
  "channel": "${CHANNEL}",
  "started": "${now}",
  "last_used": "${now}"
}
EOF
    log_ok "Session saved: ${session_id}"
}

update_session_timestamp() {
    if [[ -f "$SESSION_FILE" ]]; then
        local now tmp_file
        now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        tmp_file=$(mktemp)
        jq --arg ts "$now" '.last_used = $ts' "$SESSION_FILE" > "$tmp_file" && mv "$tmp_file" "$SESSION_FILE"
    fi
}

start_new_session() {
    log_info "Starting new Codex session..."
    local init_prompt="You are codex, a persistent AI agent in a multi-agent collaboration system.

## Your Runtime Environment
You are running on VM 901 (codex) at Tailscale IP 100.88.166.68.
Your daemon polls /mnt/shared/collab/channels/${CHANNEL}/ for messages.
You can execute approved commands by including command blocks in your responses.

## Command Execution
Include a command block like this:
\`\`\`command
{\"name\": \"github-helper\", \"subcommand\": \"list-issues\", \"args\": {\"repo\": \"agent-collab\"}}
\`\`\`

Available commands:
- github-helper: list-issues, get-issue, get-comments, comment, create-issue
- discovery: hostname, ip, whoami, uptime, env

Use discovery commands to verify your runtime environment.

You're watching the '${CHANNEL}' channel. Respond with: 'Session initialized on VM 901 (codex). Ready for messages.'"

    local output session_id
    # Run codex directly (daemon runs on codex VM)
    output=$(codex exec --skip-git-repo-check "$init_prompt" 2>&1) || {
        log_err "Failed to start Codex session"
        return 1
    }

    session_id=$(echo "$output" | grep -o 'session id: [a-f0-9-]*' | sed 's/session id: //')

    if [[ -n "$session_id" ]]; then
        save_session_id "$session_id"
        log_ok "New session started: ${session_id}"
        echo "$session_id"
        return 0
    else
        log_err "Could not determine session ID"
        return 1
    fi
}

invoke_codex_with_session() {
    local session_id="$1"
    local message_file="$2"
    local from text

    from=$(jq -r '.from' "$message_file")
    text=$(jq -r '.content.text // ""' "$message_file")

    log_info "Invoking Codex (session: ${session_id}) for message from ${from}..."
    log_info "[DEBUG] About to declare variables..."

    local response="" exit_code=0
    # Run codex directly (daemon runs on codex VM)
    # Disable set -e temporarily to capture exit code without crashing daemon
    log_info "About to run: codex exec resume ${session_id} ..."
    set +e
    response=$(codex exec resume "${session_id}" "Message from ${from}: ${text}" --skip-git-repo-check 2>&1)
    exit_code=$?
    set -e
    log_info "Codex command completed with exit code: ${exit_code}"
    log_info "[DEBUG] Response length: ${#response}"

    if [[ $exit_code -ne 0 ]]; then
        log_err "Codex exec resume failed (exit code: ${exit_code})"
        log_err "Response was: ${response:0:500}"  # Log first 500 chars for debugging
        return 1
    fi

    # Validate we got some response
    if [[ -z "$response" ]]; then
        log_err "Codex returned empty response"
        return 1
    fi

    log_info "[DEBUG] About to update session timestamp..."
    update_session_timestamp || log_warn "Failed to update session timestamp"
    log_info "[DEBUG] Session timestamp updated, about to clean response..."
    log_info "[DEBUG] Response first 100 chars: ${response:0:100}"

    # Clean response - remove all Codex metadata and only keep the actual response
    # Protected with || true to prevent daemon crash on regex failures
    local cleaned_response=""
    log_info "[DEBUG] Starting Python cleaning..."
    set +e
    cleaned_response=$(echo "$response" | python3 -c "
import sys, re

content = sys.stdin.read()

# Remove Codex header section (everything before 'user' line)
parts = re.split(r'^user$', content, maxsplit=1, flags=re.MULTILINE)
if len(parts) > 1:
    content = parts[1]

# Remove the echoed prompt (Message from ...)
content = re.sub(r'^Message from [^:]+:.*$', '', content, flags=re.MULTILINE)

# Remove common Codex output markers
patterns = [
    r'^mcp startup:.*$',
    r'^thinking$',
    r'^\*\*[^*]+\*\*$',  # thinking headers like **Answering**
    r'^codex$',
    r'^tokens used.*',
]
for pattern in patterns:
    content = re.sub(pattern, '', content, flags=re.MULTILINE | (re.DOTALL if 'tokens' in pattern else 0))

# Clean up whitespace
content = re.sub(r'\n{3,}', '\n\n', content)
print(content.strip())
" 2>/dev/null)
    local py_exit=$?
    set -e
    log_info "[DEBUG] Python cleaning done, exit code: ${py_exit}, result length: ${#cleaned_response}"

    # If cleaning failed, use raw response (truncated)
    if [[ -z "$cleaned_response" ]]; then
        log_warn "Response cleaning failed, using raw response"
        cleaned_response="${response:0:4000}"
    fi

    log_info "[DEBUG] About to return cleaned response (${#cleaned_response} chars)"
    echo "$cleaned_response"
}

post_response() {
    local response="$1"
    local in_reply_to="$2"

    # Simple file-based message posting (no Python dependencies needed)
    # Using atomic write pattern: write to .tmp, then rename
    local timestamp msg_id random_hex tmp_file final_file
    timestamp=$(date -u +"%Y%m%d-%H%M%S")
    random_hex=$(head -c 2 /dev/urandom | xxd -p)
    msg_id="msg-${timestamp}-${AGENT_ID}-${random_hex}"

    log_info "[DEBUG post_response] Creating message: ${msg_id}"

    # Create JSON message using Python with stdin for safe text handling
    local json_content
    json_content=$(echo "$response" | python3 -c "
import json
import sys
from datetime import datetime, timezone

response_text = sys.stdin.read()

msg = {
    'id': '${msg_id}',
    'timestamp': datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
    'session_id': '${CHANNEL}',
    'from': '${AGENT_ID}',
    'to': 'all',
    'type': 'chat',
    'content': {
        'text': response_text,
        'code': None,
        'artifacts': []
    },
    'metadata': {
        'mode': 'daemon',
        'session_persistent': True,
        'in_reply_to': '${in_reply_to}'
    }
}
print(json.dumps(msg, indent=2))
")

    # Atomic write: tmp file, then rename
    tmp_file="${CHANNEL_DIR}/.tmp-${msg_id}.json"
    final_file="${CHANNEL_DIR}/${msg_id}.json"

    echo "$json_content" > "$tmp_file"
    mv "$tmp_file" "$final_file"

    log_info "[DEBUG post_response] Message posted: ${final_file}"
    return 0
}

update_presence() {
    python3 << EOF
import json
from datetime import datetime, timezone
from pathlib import Path

presence = {
    "agent_id": "${AGENT_ID}",
    "state": "$1",
    "substate": "$2",
    "timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
    "channel": "${CHANNEL}",
    "mode": "daemon",
    "session_persistent": True
}

outfile = Path("${PRESENCE_DIR}") / "${AGENT_ID}.json"
with open(outfile, 'w') as f:
    json.dump(presence, f, indent=2)
EOF
}

is_for_us() {
    local file="$1"
    local to from text
    to=$(jq -r '.to // "all"' "$file")
    from=$(jq -r '.from' "$file")
    text=$(jq -r '.content.text // ""' "$file")

    [[ "$from" == "$AGENT_ID" ]] && return 1
    [[ "$to" == "$AGENT_ID" ]] && return 0
    [[ "$text" == *"@${AGENT_ID}"* ]] && return 0
    [[ "$text" == *"codex-1"* ]] && return 0
    [[ "$text" == *"codex"* ]] && return 0
    return 1
}

cleanup() {
    log_info "Shutting down ${AGENT_ID} daemon..."
    update_presence "SLEEPING" "SHUTDOWN"
    log_ok "Daemon stopped. Session preserved in ${SESSION_FILE}"
}

trap cleanup EXIT

main() {
    log_info "Starting ${AGENT_ID} daemon (persistent session mode)"
    log_info "Channel: ${CHANNEL}"
    log_info "Watching: ${CHANNEL_DIR}"

    mkdir -p "$CHANNEL_DIR" "$PRESENCE_DIR" "$(dirname "$SESSION_FILE")" "$(dirname "$LOG_FILE")"

    local session_id
    if session_id=$(get_session_id); then
        log_ok "Resuming existing session: ${session_id}"
    else
        session_id=$(start_new_session) || { log_err "Failed to start session"; exit 1; }
    fi

    update_presence "AWAKE" "IDLE"
    log_ok "Presence updated: AWAKE/IDLE"

    # Initial heartbeat for supervisor
    write_heartbeat "idle"
    log_ok "Heartbeat initialized"

    declare -A seen_messages
    for f in "${CHANNEL_DIR}"/msg-*.json; do
        [[ -f "$f" ]] && seen_messages["$(basename "$f")"]=1
    done
    local count=${#seen_messages[@]}
    log_info "Marked ${count} existing messages as read"

    log_info "Polling for messages every ${POLL_INTERVAL}s... Press Ctrl+C to stop"

    local idle_heartbeat_counter=0
    # Poll for new messages (NFS-compatible, unlike inotifywait)
    while true; do
        # Update heartbeat every 5 poll cycles (10s) while idle
        ((idle_heartbeat_counter++)) || true
        if [[ $idle_heartbeat_counter -ge 5 ]]; then
            write_heartbeat "idle"
            idle_heartbeat_counter=0
        fi
        # Get list of message files and check for new ones
        for filepath in "${CHANNEL_DIR}"/msg-*.json; do
            [[ ! -f "$filepath" ]] && continue

            local filename
            filename=$(basename "$filepath")

            # Skip already seen messages
            [[ -n "${seen_messages[$filename]:-}" ]] && continue
            seen_messages["$filename"]=1

            if is_for_us "$filepath"; then
                log_info "New message for us: ${filename}"
                update_presence "AWAKE" "WORKING"
                write_heartbeat "processing" "$filename"

                local msg_id response
                msg_id=$(jq -r '.id' "$filepath")
                log_info "[DEBUG main] About to invoke_codex_with_session..."

                set +e
                response=$(invoke_codex_with_session "$session_id" "$filepath")
                local invoke_exit=$?
                set -e
                log_info "[DEBUG main] invoke returned exit: ${invoke_exit}, response: '${response:0:50}'"

                if [[ $invoke_exit -eq 0 ]] && [[ -n "$response" ]]; then
                    log_info "[DEBUG main] About to post_response..."
                    post_response "$response" "$msg_id"
                    log_ok "Response posted"

                    # Check for command blocks and execute them
                    local cmd_result
                    if cmd_result=$(echo "$response" | /mnt/shared/collab/scripts/execute-command-block.py "$AGENT_ID" 2>/dev/null); then
                        if [[ -n "$cmd_result" ]]; then
                            log_info "Command block executed, posting result"
                            post_response "$cmd_result" "$msg_id"
                            log_ok "Command result posted"
                        fi
                    fi
                    # Increment message count after successful processing
                    log_info "[DEBUG main] Incrementing message count..."
                    ((MESSAGE_COUNT++)) || true
                else
                    log_err "Failed to get response from Codex (exit: ${invoke_exit})"
                fi

                update_presence "AWAKE" "IDLE"
                write_heartbeat "idle" "$msg_id"
            else
                log_info "Message not for us: ${filename}"
            fi
        done

        # Sleep before next poll
        sleep "$POLL_INTERVAL"
    done
}

main "$@"
