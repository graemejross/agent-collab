#!/bin/bash
#
# codex-watcher - Persistent watcher that makes Codex respond to channel messages
#
# This script:
# 1. Watches the channel for new messages using inotifywait (zero AI tokens)
# 2. When a message is addressed to codex-1, gathers context
# 3. Invokes Codex with the context
# 4. Posts Codex's response back to the channel
#
# Usage:
#   codex-watcher <channel>
#   codex-watcher aqara-trv-automation
#
# Run in tmux for persistence:
#   tmux new-session -d -s codex-watcher './codex-watcher aqara-trv-automation'
#

set -e

CHANNEL="${1:-aqara-trv-automation}"
CHANNEL_DIR="/mnt/shared/collab/channels/${CHANNEL}"
PRESENCE_DIR="/mnt/shared/collab/presence"
AGENT="codex-1"
CODEX_VM="100.88.166.68"
LOG_FILE="/mnt/shared/collab/logs/codex-watcher.log"

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo -e "${msg}" >&2
    echo "${msg}" >> "${LOG_FILE}" 2>/dev/null || true
}

log_info() { log "${BLUE}INFO${NC}: $1"; }
log_ok() { log "${GREEN}OK${NC}: $1"; }
log_warn() { log "${YELLOW}WARN${NC}: $1"; }
log_err() { log "${RED}ERROR${NC}: $1"; }

# Ensure directories exist
mkdir -p "${PRESENCE_DIR}" "$(dirname "${LOG_FILE}")" 2>/dev/null || true

# Update presence file
update_presence() {
    local state="${1:-IDLE}"
    cat > "${PRESENCE_DIR}/${AGENT}.json" << EOF
{
  "agent_id": "${AGENT}",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
  "state": "AWAKE",
  "substate": "${state}",
  "watcher_pid": $$,
  "channel": "${CHANNEL}"
}
EOF
}

# Check if message is addressed to us
is_for_us() {
    local file="$1"
    local to=$(jq -r '.to // "all"' "$file" 2>/dev/null)
    local mentions=$(jq -r '.content.text // ""' "$file" 2>/dev/null | grep -o "@${AGENT}" || true)

    [[ "$to" == "$AGENT" ]] || [[ "$to" == "codex-1" ]] || [[ -n "$mentions" ]]
}

# Check if message is from us (don't respond to ourselves)
is_from_us() {
    local file="$1"
    local from=$(jq -r '.from // ""' "$file" 2>/dev/null)
    [[ "$from" == "$AGENT" ]] || [[ "$from" == "codex-1" ]]
}

# Get recent context (last N messages)
get_context() {
    local n="${1:-5}"
    local context=""

    for f in $(ls -t "${CHANNEL_DIR}"/msg-*.json 2>/dev/null | head -n "$n" | tac); do
        local from=$(jq -r '.from' "$f" 2>/dev/null)
        local text=$(jq -r '.content.text // ""' "$f" 2>/dev/null)
        context="${context}[${from}]: ${text}\n\n"
    done

    echo -e "$context"
}

# Get long-term memory (state files)
get_memory() {
    local memory=""

    # Include CURRENT-STATE.md if it exists
    if [[ -f "/mnt/shared/collab/CURRENT-STATE.md" ]]; then
        memory="${memory}=== CURRENT STATE (Long-term Memory) ===\n"
        memory="${memory}$(head -100 /mnt/shared/collab/CURRENT-STATE.md)\n\n"
    fi

    echo -e "$memory"
}

# Invoke Codex and get response
invoke_codex() {
    local message_file="$1"
    local from=$(jq -r '.from' "$message_file")
    local text=$(jq -r '.content.text // ""' "$message_file")
    local msg_type=$(jq -r '.type // "chat"' "$message_file")
    local context=$(get_context 10)
    local memory=$(get_memory)

    # Write prompt to shared location (avoids shell escaping issues)
    local prompt_file="/mnt/shared/collab/workspace/.codex-prompt-$$.txt"
    cat > "$prompt_file" << PROMPT_EOF
You are codex-1 in a multi-agent collaboration system. You're responding to a message in the ${CHANNEL} channel.

${memory}

=== RECENT CHANNEL MESSAGES ===
${context}

=== LATEST MESSAGE (from ${from}) ===
${text}

Respond appropriately. Keep your response focused and concise.
- You have access to CURRENT-STATE.md above - use it for context about past discussions
- Do NOT run startup scripts
- Do NOT ask about projects
- Just respond to the message directly
- Output ONLY your response text
PROMPT_EOF

    # Invoke Codex on the remote VM, reading prompt from shared file
    log_info "Invoking Codex for message from ${from}..."

    local response
    response=$(ssh graeme@${CODEX_VM} "codex exec --skip-git-repo-check --sandbox danger-full-access \"\$(cat ${prompt_file})\"" 2>&1) || {
        log_err "Codex invocation failed: $response"
        rm -f "$prompt_file"
        return 1
    }

    rm -f "$prompt_file"

    # Extract just the response (remove Codex metadata, token count, duplicates, logs)
    # The actual response comes after "codex" line and before "tokens used"
    echo "$response" | \
        sed 's/\x1b\[[0-9;]*m//g' | \
        sed -n '/^codex$/,/^tokens used/p' | \
        grep -v "^codex$" | \
        grep -v "^tokens used" | \
        grep -v "^\[" | \
        grep -v "INFO" | \
        grep -v "Invoking" | \
        grep -v "^$" | \
        uniq | \
        head -20
}

# Post response to channel
post_response() {
    local response_text="$1"
    local in_reply_to="$2"

    # Use Python to write proper JSON
    python3 << EOF
import json
from datetime import datetime, timezone
from pathlib import Path
import secrets

now = datetime.now(timezone.utc)
msg_id = f"msg-{now.strftime('%Y%m%d-%H%M%S')}-codex-{secrets.token_hex(2)}"

msg = {
    "id": msg_id,
    "timestamp": now.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
    "session_id": "${CHANNEL}",
    "from": "codex-1",
    "to": "all",
    "type": "chat",
    "content": {
        "text": """${response_text}""",
        "code": None,
        "artifacts": []
    },
    "metadata": {
        "mode": "watcher",
        "in_reply_to": "${in_reply_to}"
    }
}

path = Path("${CHANNEL_DIR}") / f"{msg_id}.json"
path.write_text(json.dumps(msg, indent=2) + "\n")
print(f"Posted: {msg_id}")
EOF
}

# Main watch loop
main() {
    log_info "Starting Codex watcher for channel: ${CHANNEL}"
    log_info "Watching: ${CHANNEL_DIR}"
    log_info "Press Ctrl+C to stop"

    # Check dependencies
    if ! command -v inotifywait &> /dev/null; then
        log_err "inotifywait not found. Install with: apt install inotify-tools"
        exit 1
    fi

    if ! command -v jq &> /dev/null; then
        log_err "jq not found. Install with: apt install jq"
        exit 1
    fi

    # Initial presence
    update_presence "IDLE"
    log_ok "Presence updated: AWAKE/IDLE"

    # Track processed files to avoid duplicates
    declare -A processed

    # Mark existing files as processed
    for f in "${CHANNEL_DIR}"/msg-*.json; do
        [[ -f "$f" ]] && processed["$(basename "$f")"]=1
    done
    log_info "Marked ${#processed[@]} existing messages as read"

    # Watch for new files
    inotifywait -m -e create -e moved_to "${CHANNEL_DIR}" --format '%f' 2>/dev/null | while read -r filename; do
        # Skip non-message files
        [[ "$filename" != msg-*.json ]] && continue

        # Skip already processed
        [[ -n "${processed[$filename]}" ]] && continue
        processed["$filename"]=1

        local filepath="${CHANNEL_DIR}/${filename}"

        # Wait a moment for file to be fully written
        sleep 0.5

        # Skip our own messages
        if is_from_us "$filepath"; then
            log_info "Skipping own message: ${filename}"
            continue
        fi

        # Check if addressed to us
        if ! is_for_us "$filepath"; then
            log_info "Message not for us: ${filename}"
            continue
        fi

        log_info "New message for us: ${filename}"
        update_presence "WORKING"

        # Get the message ID for reply tracking
        local msg_id=$(jq -r '.id' "$filepath" 2>/dev/null)

        # Invoke Codex and get response
        local response
        if response=$(invoke_codex "$filepath"); then
            if [[ -n "$response" ]]; then
                log_ok "Got response from Codex"
                post_response "$response" "$msg_id"
            else
                log_warn "Empty response from Codex"
            fi
        else
            log_err "Failed to get response from Codex"
        fi

        update_presence "IDLE"
    done
}

# Handle shutdown
cleanup() {
    log_info "Shutting down watcher..."
    update_presence "OFFLINE"
    exit 0
}

trap cleanup SIGINT SIGTERM

main "$@"
