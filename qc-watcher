#!/bin/bash
#
# qc-watcher - Quality Control agent watcher
#
# Uses Gemini Flash for rapid validation tasks:
# - Pre-commit checks
# - Evidence bundle validation
# - Issue-commit linkage
# - Format/lint validation
#
# Usage:
#   qc-watcher <channel>
#
# Run in tmux:
#   tmux new-session -d -s qc-watcher '/mnt/shared/collab/scripts/qc-watcher agent-os-paper'
#

set -e

CHANNEL="${1:-agent-os-paper}"
CHANNEL_DIR="/mnt/shared/collab/channels/${CHANNEL}"
PRESENCE_DIR="/mnt/shared/collab/presence"
SCRIPTS_DIR="/mnt/shared/collab/scripts"
AGENT="qc-1"
LOG_FILE="/mnt/shared/collab/logs/qc-watcher.log"

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo -e "${msg}" >&2
    echo "${msg}" >> "${LOG_FILE}" 2>/dev/null || true
}

log_info() { log "${CYAN}INFO${NC}: $1"; }
log_ok() { log "${GREEN}OK${NC}: $1"; }
log_warn() { log "${YELLOW}WARN${NC}: $1"; }
log_err() { log "${RED}ERROR${NC}: $1"; }

# Ensure directories exist
mkdir -p "${PRESENCE_DIR}" "$(dirname "${LOG_FILE}")" 2>/dev/null || true

# Update presence file
update_presence() {
    local state="${1:-IDLE}"
    cat > "${PRESENCE_DIR}/${AGENT}.json" << EOF
{
  "agent_id": "${AGENT}",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
  "state": "AWAKE",
  "substate": "${state}",
  "watcher_pid": $$,
  "channel": "${CHANNEL}"
}
EOF
}

# Check if message is addressed to us
is_for_us() {
    local file="$1"
    local to=$(jq -r '.to // "all"' "$file" 2>/dev/null)
    local mentions=$(jq -r '.content.text // ""' "$file" 2>/dev/null | grep -o "@${AGENT}" || true)

    [[ "$to" == "$AGENT" ]] || [[ "$to" == "qc-1" ]] || [[ -n "$mentions" ]]
}

# Check if message is from us
is_from_us() {
    local file="$1"
    local from=$(jq -r '.from // ""' "$file" 2>/dev/null)
    [[ "$from" == "$AGENT" ]] || [[ "$from" == "qc-1" ]]
}

# Get recent context
get_context() {
    local n="${1:-5}"
    local context=""

    for f in $(ls -t "${CHANNEL_DIR}"/msg-*.json 2>/dev/null | head -n "$n" | tac); do
        local from=$(jq -r '.from' "$f" 2>/dev/null)
        local text=$(jq -r '.content.text // ""' "$f" 2>/dev/null)
        context="${context}[${from}]: ${text}\n\n"
    done

    echo -e "$context"
}

# Invoke Gemini with QC-specific prompt
invoke_qc() {
    local message_file="$1"
    local from=$(jq -r '.from' "$message_file")
    local text=$(jq -r '.content.text // ""' "$message_file")
    local context=$(get_context 10)

    # QC-specific system prompt
    local prompt="You are qc-1, the Quality Control agent in a multi-agent collaboration system.

YOUR ROLE:
- Validate evidence bundles for completeness
- Check issue-commit linkage
- Verify formatting and structure
- Flag potential problems
- You are READ-ONLY - you cannot modify code or approve changes
- You can only RECOMMEND approval or flag issues

YOUR CAPABILITIES:
- Validate JSON/YAML syntax
- Check markdown formatting
- Verify required fields in evidence bundles
- Check for missing issue references
- Identify potential security concerns

YOUR GUARDRAILS:
- Never approve high-risk changes without escalating to supervisor
- Always provide structured feedback
- Be concise and actionable

=== RECENT CHANNEL MESSAGES ===
${context}

=== REQUEST FROM ${from} ===
${text}

Respond with your quality assessment. Be concise. If this is a review request, structure your response as:
- CHECKS: What you validated
- ISSUES: Problems found (or 'None')
- RECOMMENDATION: approve / request_changes / escalate_to_supervisor"

    log_info "Invoking QC check for message from ${from}..."

    local response
    response=$("${SCRIPTS_DIR}/gemini-exec" "$prompt" 2>&1) || {
        log_err "QC invocation failed: $response"
        return 1
    }

    echo "$response"
}

# Post response to channel
post_response() {
    local response_text="$1"
    local in_reply_to="$2"

    python3 << EOF
import json
from datetime import datetime, timezone
from pathlib import Path
import secrets

now = datetime.now(timezone.utc)
msg_id = f"msg-{now.strftime('%Y%m%d-%H%M%S')}-qc-{secrets.token_hex(2)}"

msg = {
    "id": msg_id,
    "timestamp": now.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
    "session_id": "${CHANNEL}",
    "from": "qc-1",
    "to": "all",
    "type": "review",
    "content": {
        "text": """${response_text}""",
        "code": None,
        "artifacts": []
    },
    "metadata": {
        "mode": "watcher",
        "model": "gemini-2.5-flash",
        "role": "quality_control",
        "in_reply_to": "${in_reply_to}"
    }
}

path = Path("${CHANNEL_DIR}") / f"{msg_id}.json"
path.write_text(json.dumps(msg, indent=2) + "\n")
print(f"Posted: {msg_id}")
EOF
}

# Main watch loop
main() {
    log_info "Starting QC watcher for channel: ${CHANNEL}"
    log_info "Agent: ${AGENT} (Quality Control)"
    log_info "Watching: ${CHANNEL_DIR}"

    # Check dependencies
    if ! command -v inotifywait &> /dev/null; then
        log_err "inotifywait not found. Install with: apt install inotify-tools"
        exit 1
    fi

    if [[ ! -x "${SCRIPTS_DIR}/gemini-exec" ]]; then
        log_err "gemini-exec not found or not executable"
        exit 1
    fi

    # Initial presence
    update_presence "IDLE"
    log_ok "Presence updated: AWAKE/IDLE"

    # Track processed files
    declare -A processed

    # Mark existing files as processed
    for f in "${CHANNEL_DIR}"/msg-*.json; do
        [[ -f "$f" ]] && processed["$(basename "$f")"]=1
    done
    log_info "Marked ${#processed[@]} existing messages as read"

    # Watch for new files
    inotifywait -m -e create -e moved_to "${CHANNEL_DIR}" --format '%f' 2>/dev/null | while read -r filename; do
        [[ "$filename" != msg-*.json ]] && continue
        [[ -n "${processed[$filename]}" ]] && continue
        processed["$filename"]=1

        local filepath="${CHANNEL_DIR}/${filename}"
        sleep 0.5

        if is_from_us "$filepath"; then
            log_info "Skipping own message: ${filename}"
            continue
        fi

        if ! is_for_us "$filepath"; then
            log_info "Message not for us: ${filename}"
            continue
        fi

        log_info "New QC request: ${filename}"
        update_presence "REVIEWING"

        local msg_id=$(jq -r '.id' "$filepath" 2>/dev/null)

        local response
        if response=$(invoke_qc "$filepath"); then
            if [[ -n "$response" ]]; then
                log_ok "QC review complete"
                post_response "$response" "$msg_id"
            else
                log_warn "Empty response from QC"
            fi
        else
            log_err "QC review failed"
        fi

        update_presence "IDLE"
    done
}

cleanup() {
    log_info "Shutting down QC watcher..."
    update_presence "OFFLINE"
    exit 0
}

trap cleanup SIGINT SIGTERM

main "$@"
