#!/bin/bash
#
# triage-watcher - Incident Triage agent watcher
#
# Uses Gemini Flash for rapid incident classification:
# - Severity assessment (P1-P4)
# - Routing to appropriate agent/human
# - Initial diagnostics gathering
# - Escalation tracking
#
# Usage:
#   triage-watcher <channel>
#
# Run in tmux:
#   tmux new-session -d -s triage-watcher '/mnt/shared/collab/scripts/triage-watcher agent-os-paper'
#

set -e

CHANNEL="${1:-agent-os-paper}"
CHANNEL_DIR="/mnt/shared/collab/channels/${CHANNEL}"
PRESENCE_DIR="/mnt/shared/collab/presence"
SCRIPTS_DIR="/mnt/shared/collab/scripts"
AGENT="triage-1"
LOG_FILE="/mnt/shared/collab/logs/triage-watcher.log"

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
MAGENTA='\033[0;35m'
NC='\033[0m'

log() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo -e "${msg}" >&2
    echo "${msg}" >> "${LOG_FILE}" 2>/dev/null || true
}

log_info() { log "${MAGENTA}INFO${NC}: $1"; }
log_ok() { log "${GREEN}OK${NC}: $1"; }
log_warn() { log "${YELLOW}WARN${NC}: $1"; }
log_err() { log "${RED}ERROR${NC}: $1"; }

# Ensure directories exist
mkdir -p "${PRESENCE_DIR}" "$(dirname "${LOG_FILE}")" 2>/dev/null || true

# Update presence file
update_presence() {
    local state="${1:-IDLE}"
    cat > "${PRESENCE_DIR}/${AGENT}.json" << EOF
{
  "agent_id": "${AGENT}",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
  "state": "AWAKE",
  "substate": "${state}",
  "watcher_pid": $$,
  "channel": "${CHANNEL}"
}
EOF
}

# Check if message is addressed to us
is_for_us() {
    local file="$1"
    local to=$(jq -r '.to // "all"' "$file" 2>/dev/null)
    local mentions=$(jq -r '.content.text // ""' "$file" 2>/dev/null | grep -o "@${AGENT}" || true)

    [[ "$to" == "$AGENT" ]] || [[ "$to" == "triage-1" ]] || [[ -n "$mentions" ]]
}

# Check if message is from us
is_from_us() {
    local file="$1"
    local from=$(jq -r '.from // ""' "$file" 2>/dev/null)
    [[ "$from" == "$AGENT" ]] || [[ "$from" == "triage-1" ]]
}

# Get recent context
get_context() {
    local n="${1:-5}"
    local context=""

    for f in $(ls -t "${CHANNEL_DIR}"/msg-*.json 2>/dev/null | head -n "$n" | tac); do
        local from=$(jq -r '.from' "$f" 2>/dev/null)
        local text=$(jq -r '.content.text // ""' "$f" 2>/dev/null)
        context="${context}[${from}]: ${text}\n\n"
    done

    echo -e "$context"
}

# Get basic system diagnostics (safe, read-only)
get_diagnostics() {
    local diag=""

    # Agent status
    diag="${diag}=== AGENT STATUS ===\n"
    if [[ -x "${SCRIPTS_DIR}/who" ]]; then
        diag="${diag}$("${SCRIPTS_DIR}/who" 2>/dev/null | head -20)\n\n"
    fi

    # Recent log entries (sanitized)
    diag="${diag}=== RECENT LOGS (last 10 lines) ===\n"
    for logfile in /mnt/shared/collab/logs/*.log; do
        if [[ -f "$logfile" ]]; then
            diag="${diag}--- $(basename "$logfile") ---\n"
            diag="${diag}$(tail -5 "$logfile" 2>/dev/null | sed 's/[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}/[IP]/g')\n"
        fi
    done

    echo -e "$diag"
}

# Invoke Gemini with triage-specific prompt
invoke_triage() {
    local message_file="$1"
    local from=$(jq -r '.from' "$message_file")
    local text=$(jq -r '.content.text // ""' "$message_file")
    local context=$(get_context 10)
    local diagnostics=$(get_diagnostics)

    # Triage-specific system prompt
    local prompt="You are triage-1, the Incident Triage agent in a multi-agent collaboration system.

YOUR ROLE:
- Rapidly classify incidents by severity (P1-P4)
- Route to appropriate agent or human
- Gather initial diagnostic information
- Track and escalate time-sensitive issues
- You are READ-ONLY - you cannot fix issues, only triage them

SEVERITY LEVELS:
- P1 (CRITICAL): Service down, data loss risk, security breach
  → Route to: HUMAN + supervisor immediately
  → Response time: Immediate

- P2 (HIGH): Degraded performance, partial outage, failing backups
  → Route to: supervisor
  → Response time: < 1 hour

- P3 (MEDIUM): Non-critical feature broken, minor integration issue
  → Route to: Relevant specialized agent (ha-mgr-1, bags-1, etc.)
  → Response time: < 4 hours

- P4 (LOW): Minor issues, improvements, documentation updates
  → Route to: docs-1 to log
  → Response time: Next session

ROUTING TARGETS:
- human: Graeme (boss) - for P1 and approval
- supervisor: Claude orchestrator - for P2 and coordination
- ha-mgr-1: Home Assistant issues
- bags-1: Baggage database issues
- docs-1: Documentation issues
- qc-1: Quality/review issues
- codex-1: Implementation tasks
- gemini-1: Validation tasks

YOUR GUARDRAILS:
- Cannot fix issues directly
- Cannot restart services
- Cannot modify configurations
- Cannot access production databases
- Can only read logs from allowed paths

${diagnostics}

=== RECENT CHANNEL MESSAGES ===
${context}

=== INCIDENT REPORT FROM ${from} ===
${text}

Respond with your triage assessment. Structure your response as:

INCIDENT ID: INC-YYYYMMDD-XXX (generate one)
SEVERITY: P1/P2/P3/P4
CATEGORY: (service/database/home_assistant/documentation/security/other)
SUMMARY: (one line description)

INITIAL DIAGNOSTICS:
- (relevant findings from system status)

ROUTE TO: (agent or human)
ALSO NOTIFY: (additional parties if needed)

RECOMMENDED ACTIONS:
1. (first step)
2. (second step)

ESCALATION: (conditions that would escalate severity)"

    log_info "Invoking triage for incident from ${from}..."

    local response
    response=$("${SCRIPTS_DIR}/gemini-exec" "$prompt" 2>&1) || {
        log_err "Triage invocation failed: $response"
        return 1
    }

    echo "$response"
}

# Post response to channel
post_response() {
    local response_text="$1"
    local in_reply_to="$2"

    python3 << EOF
import json
from datetime import datetime, timezone
from pathlib import Path
import secrets

now = datetime.now(timezone.utc)
msg_id = f"msg-{now.strftime('%Y%m%d-%H%M%S')}-triage-{secrets.token_hex(2)}"

msg = {
    "id": msg_id,
    "timestamp": now.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
    "session_id": "${CHANNEL}",
    "from": "triage-1",
    "to": "all",
    "type": "triage",
    "content": {
        "text": """${response_text}""",
        "code": None,
        "artifacts": []
    },
    "metadata": {
        "mode": "watcher",
        "model": "gemini-2.5-flash",
        "role": "incident_triage",
        "in_reply_to": "${in_reply_to}"
    }
}

path = Path("${CHANNEL_DIR}") / f"{msg_id}.json"
path.write_text(json.dumps(msg, indent=2) + "\n")
print(f"Posted: {msg_id}")
EOF
}

# Main watch loop
main() {
    log_info "Starting Triage watcher for channel: ${CHANNEL}"
    log_info "Agent: ${AGENT} (Incident Triage)"
    log_info "Watching: ${CHANNEL_DIR}"

    # Check dependencies
    if ! command -v inotifywait &> /dev/null; then
        log_err "inotifywait not found. Install with: apt install inotify-tools"
        exit 1
    fi

    if [[ ! -x "${SCRIPTS_DIR}/gemini-exec" ]]; then
        log_err "gemini-exec not found or not executable"
        exit 1
    fi

    # Initial presence
    update_presence "IDLE"
    log_ok "Presence updated: AWAKE/IDLE"

    # Track processed files
    declare -A processed

    # Mark existing files as processed
    for f in "${CHANNEL_DIR}"/msg-*.json; do
        [[ -f "$f" ]] && processed["$(basename "$f")"]=1
    done
    log_info "Marked ${#processed[@]} existing messages as read"

    # Watch for new files
    inotifywait -m -e create -e moved_to "${CHANNEL_DIR}" --format '%f' 2>/dev/null | while read -r filename; do
        [[ "$filename" != msg-*.json ]] && continue
        [[ -n "${processed[$filename]}" ]] && continue
        processed["$filename"]=1

        local filepath="${CHANNEL_DIR}/${filename}"
        sleep 0.5

        if is_from_us "$filepath"; then
            log_info "Skipping own message: ${filename}"
            continue
        fi

        if ! is_for_us "$filepath"; then
            log_info "Message not for us: ${filename}"
            continue
        fi

        log_info "New incident report: ${filename}"
        update_presence "TRIAGING"

        local msg_id=$(jq -r '.id' "$filepath" 2>/dev/null)

        local response
        if response=$(invoke_triage "$filepath"); then
            if [[ -n "$response" ]]; then
                log_ok "Triage complete"
                post_response "$response" "$msg_id"
            else
                log_warn "Empty response from triage"
            fi
        else
            log_err "Triage failed"
        fi

        update_presence "IDLE"
    done
}

cleanup() {
    log_info "Shutting down Triage watcher..."
    update_presence "OFFLINE"
    exit 0
}

trap cleanup SIGINT SIGTERM

main "$@"
